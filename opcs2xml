#!/usr/bin/env python

import csv
import sys

## 06-09-2022 RJ 0.0.0 Script to convert OPCS source files to XML
## 07-09-2022 RJ 0.0.1 Completed three XML outputs, submitted for checking
## 26-09-2022 RJ 0.0.2 Prints confirmation on writing each file
## 27-08-2025 RJ 0.0.3 Amended a little to handle OPCS 4.11

# Run with no arguments.  The input and output filenames are specified below.
# Note that the TOCE file will need to be loaded into Excel and saved as a CSV
# as an initial step before running.
#   Open the TOCE*.xls file in Excel
#   File -> Save As
#   Change the file type to CSV
#   Save

# To keep external dependencies to a minimum, XML output is manual and it's
# very simple anyway.

# Note that

# Generally all the files will have the same source date in them
source_date = "20250829_3"                      # Ok, it has some sort of suffix as well as the date
version = 4.11                                  # Version of OPCS we're working with
file_version = str(version).replace(".", "")    # So, 4.11 -> "411"

c_src = f"CodesAndTitles_{source_date}.txt"
m_src = f"MetaData_{source_date}.txt"
t_src = f"TOCE_{file_version}_{source_date}.csv"

c_dest = f"codes_{file_version}.xml"
m_dest = f"meta_{file_version}.xml"
t_dest = f"toce_{file_version}.xml"

def Fatal(file, line, text):
    print(f"Fatal error in {file}:{line} - {text}", file=sys.stderr)
    exit(99)

def xml_esc(text):
    """ Perform XML escaping of anything that doesn't sit nicely as element text

        These are attributes enclosed in " so just need the four escapes to be safe.
    """

    return (text
        .replace("&", "&amp;")
        .replace("\"", "&quot;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
    )

def out(fd, level, text):
    """ Output the text to the file as a line indented level 'indents'
    """

    indent = level * "    "
    nl = "\n"
    fd.write(indent + text + nl)

def do_codes(src, dest):
    """ Process CodesAndTitles txt -> xml

        Source is nicely TAB separated - two columns.
    """

    # Column 1 is the CODE
    # Column 2 is the TITLE
    with open(dest, "w") as d:
        out(d, 0, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
        out(d, 0, "<dsv xmlns=\"https://www.digital.nhs.uk/opcs/codes\">")
        with open(src) as fd:
            lineno = 0
            for line in fd:
                lineno += 1
                line = line.rstrip()
                if not line:
                    continue
                try:
                    code, title = line.split("\t", 1)
                    code = xml_esc(code)
                    title = xml_esc(title)
                    output = f"<code CODE=\"{xml_esc(code)}\" TITLE=\"{title}\"/>"
                    out(d, 1, output)
                except Exception as e:
                    Fatal(src, lineno, f"{e}")
        out(d, 0, "</dsv>")
    print(f"Processed {lineno:,} lines into {dest}")

def do_meta(src, dest):
    """ Process MetaData txt -> xml

        src is space separated with data at columns
    """
    # 1           A011        MAJOR EXCISION OF TISSUE OF BRAIN                           HEMISPHERECTOMY                                                                                              01                                 1
    # 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
    # 0         1         2         3         4         5         6         7         8         9        10        11        12        13        14        15        16        17        18        19        20        21        22        23
    with open(dest, "w") as d:
        out(d, 0, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
        out(d, 0, "<dsv xmlns=\"https://www.digital.nhs.uk/opcs/meta\">")
        with open(src, "rb") as fd:
            try:
                for lineno, line in enumerate(fd, start=1):
                    if b'\xa0' in line:
                        highlight = line.replace(b'\xa0', b'*').decode().rstrip()
                        line = line.replace(b'\xa0', b' ')
                        print(f"0xa0 replaced on line {lineno}: {highlight}")
                    line = line.decode()
                    line = line.rstrip()
                    if not line:
                        continue
                    line += " " * (228 - len(line))
                    attrs = {}
                    a = line[0:12].rstrip()                         # We don't use the leading 1
                    oc = line[12:24].rstrip()                       # operation code provided without '.'
                    operation_code = oc[:3] + "." + oc[3:]          # Add in the '.'
                    operation_name_3 = line[24:84].rstrip()
                    operation_name_4 = line[84:191].rstrip()
                    sex_scrutiny = line[191:193].rstrip()           # Not always provided - appears just before the '01' in the example
                    status_operation = line[193:218].rstrip()
                    delivery = len(line[218:].rstrip())             # Appears as a '1' in a column depending on the delivery method
                    if delivery:
                        attrs["METHOD_DELIVERY"] = delivery - 1
                    attrs["OPERATION_CODE"] = operation_code
                    attrs["OPERATION_NAME_3"] = operation_name_3
                    attrs["OPERATION_NAME_4"] = operation_name_4
                    if sex_scrutiny:
                        attrs["SEX_SCRUTINY"] = sex_scrutiny
                    attrs["STATUS_OPERATION"] = status_operation

                    output = "<meta"

                    for name, value in attrs.items():
                        entry = f"{name}=\"{xml_esc(str(value))}\""
                        if len(output + entry) > 80:
                            out(d, 1, output)
                            output = "    "
                        output += " " + entry
                    out(d, 1, output + "/>")
            except Exception as e:
                Fatal(src, lineno, f"{e}")
        out(d, 0, "</dsv>")
    print(f"Processed {lineno:,} lines into {dest}")

def do_toce(src, dest):
    """ Process TOCE xls -> xml

        src is a CSV saved from Excel
    """
    # Fields are:
    # 1..n-1    Codes for OPCS4.2 ... OPCS 4.10...
    # n         Description
    # n+1       Notes for OPCS {version} ... OPCS 4.2 - we're only interested in the 4.{version} one in column n+1 (older notes are to the right of it)
    # n is 10 for version 4.10, 11 for version 4.11 etc.
    n = int(version * 100) - 400       # E.g. 4.11 will become 11
    descr_col = n - 1
    notes_col = n
    with open(dest, "w") as d:
        out(d, 0, "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>")
        out(d, 0, "<dsv xmlns=\"https://www.digital.nhs.uk/opcs/toce\">")
        with open(src, newline='') as fd:
            lineno = 0
            spamreader = csv.reader(fd)
            for row in spamreader:
                lineno += 1
                if lineno == 1:
                    continue

                attrs = {}
                descr = row[descr_col]
                parts = descr.split(": ")           # Appears as "code: description"
                if len(parts) != 2:
                    Fatal(src, lineno, f"Expecting 'code: description', for '{descr}'")
                attrs["DESCRIPTION"] = parts[1]
                for i in range(n - 1):
                    attrs[f"OPCS_4{i + 2}"] = row[i]
                if row[notes_col]:
                    attrs["NOTES"] = row[notes_col]

                output = "<code"
                for name, value in attrs.items():
                    entry = f"{name}=\"{xml_esc(str(value))}\""
                    if len(output + entry) > 80:
                        out(d, 1, output)
                        output = "    "
                    output += " " + entry
                out(d, 1, output + "/>")
        out(d, 0, "</dsv>")
    print(f"Processed {lineno:,} lines into {dest}")

if __name__ == "__main__":
    do_codes(c_src, c_dest)
    do_meta(m_src, m_dest)
    do_toce(t_src, t_dest)

