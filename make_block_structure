#!/usr/bin/env python3

""" Looks for the most recent Tabular_*.rtf file in the current directory (or is given the name on the command line)
    processing it to produce:
    * A 'Block Structure' .csv file in the same directory
    * A 'Block Structure' .xlxs file in the same directory if the openpyxl module is installed
"""

# 27-08-2025 RJ 0.0.0 Create 'Block Structure' file
# 04-09-2025 RJ 0.0.1 Tidied up and added CSV and Excel output
# 05-09-2025 RJ 0.0.2 Excluded deleted and retired codes and generated notes sheet

import csv
import re
import sys

from pathlib import Path
from typing import TypeVar, NoReturn, Optional

try:
    import openpyxl
    from openpyxl import Workbook
    from openpyxl.styles import Border, Side, PatternFill, Font, Alignment
except ImportError:
    openpyxl = None

T = TypeVar("T")
_func_cache = {}

_debugging = False      # Set to True to enable debug output

def Fatal(msg: str) -> NoReturn:
    print(msg, file=sys.stderr)
    exit(99)

def Debug(msg: str) -> None:
    if _debugging:
        print(f"DEBUG: {msg}", file=sys.stderr)

# Just experimenting if this is any use
def static_attr(name: str, default: T) -> T:
    frame = sys._getframe(1)
    code = frame.f_code

    # Cache the function object per code object
    func = _func_cache.get(code)
    if func is None:
        func = frame.f_locals.get(code.co_name) or frame.f_globals.get(code.co_name)
        if not callable(func):
            raise RuntimeError(f"Cannot resolve calling function: {code.co_name}")
        _func_cache[code] = func

    if not hasattr(func, name):
        setattr(func, name, default)
    return getattr(func, name)


def rtf_to_text(rtf_content: str) -> list[str]:
    """ Fillet RTF content, returning a list of plain text lines.

        We remove most of the RTF formatting, keeping the line structure and tabs.
    """
    # Remove groups like font/color tables: {\*\fonttbl...}, {\*\colortbl...}, etc.
    text = re.sub(r'{\\\*?\\[^{}]+}|{\\\*?[^{}]+}', '', rtf_content)

    # Convert escaped hex codes: \'hh â†’ corresponding character
    text = re.sub(r"\\'([0-9a-fA-F]{2})", lambda m: bytes.fromhex(m.group(1)).decode('latin1'), text)

    # Translate the RTF control words that we want to keep
    text = text.replace("\\pard", "\n").replace("\\par", "\n")
    text = text.replace("\\tab", "\t")

    # Remove remaining RTF control words (e.g. \b, \par, \fs24, etc.)
    text = re.sub(r'\\[-a-zA-Z]+\d* ?', '', text)

    # Remove escaped braces and backslashes
    text = text.replace('\\{', '{').replace('\\}', '}').replace('\\\\', '\\')

    # Remove leftover braces entirely
    text = re.sub(r'[{}]', '', text)

    # Normalize line breaks: RTF uses \par for paragraphs
    text = text.replace('\r', '\n').replace('\n\n', '\n')

    # Split into individual lines and strip whitespace
    lines = [line.strip() for line in text.splitlines() if line.strip()]

    return lines

def process_codes(codes: list[str], title: str):
    """ Process a list of codes such as A01, A02, A03, A05, A06, A08, A10, A11, A12
        and format them into a nice list (A01-A03, A05-A06, A08, A10-A12) preceding the title
        Then map all the codes to the result
    """
    groups: list[int] = []      # Each group is a list of (start, end)
    for code in codes:
        chapter = code[0]
        num = code[1:]

        if not groups or int(groups[-1][1]) + 1 != int(num):
            groups.append([num, num])
            continue

        groups[-1][1] = num
    result = ", ".join([f"{chapter}{start}" if start == end else f"{chapter}{start}-{chapter}{end}" for start, end in groups]) + f" {title}"

    for code in codes:
        ranges[code] = result

def part1(line: str):
    """ Collect the information on range that can only be gleaned from part 1
    """
    part1.title = static_attr("title", "?")
    if not "\t" in line:
        if codes:
            process_codes(codes, part1.title)
        codes.clear()
        part1.title = re.sub(r"\s*\([^)]*\)$", "", line)
        return
    code = line.split("\t", 1)[0]
    codes.append(code)

last_row = 0    # Keep track of the last row (much quicker than ws.last_row)

# Define some styles here as, although the calls are cached internally, they're still relatively slow
if openpyxl:
    header_fill = PatternFill(start_color="FFFF99", end_color="FFFF99", fill_type="solid")
    header_font = Font(name="Arial", bold=True)
    centre_align = Alignment(horizontal="center")

    body_font = Font(name="Arial")

    thin_border = Border(left=Side(style="thin"), right=Side(style="thin"), top=Side(style="thin"), bottom=Side(style="thin"))

def output(row: list[str], style: str, sheet: Optional[Workbook]=None):
    """ Output a row in whatever format(s) we need

        style and sheet only apply if we're outputing to Excel
        style:  "plain", "heading" or "body"
        sheet:  The sheet to output to (default is ws)
    """

    # Excel
    output.row_counts = static_attr("row_counts", {})
    if openpyxl:
        if not sheet:
            sheet = ws

        # This is much quicker than using ws.row_count on deep sheets
        last_row = output.row_counts.get(sheet, 0) + 1
        output.row_counts[sheet] = last_row

        sheet.append(row)
        row = sheet[last_row]
        if style == "heading":
            for cell in row:       # Heading row wants some styling
                cell.fill = header_fill
                cell.font = header_font
                cell.alignment = centre_align
                cell.border = thin_border
        elif style == "body":
            for cell in row:           # All cells want borders
                cell.border = thin_border

        for cell in row:                # All rows want just font setting
            cell.font = body_font

    # CSV
    writer.writerow(row)

if __name__ == "__main__":
    # Find the most recent file in the current directory if we've not been given one
    if len(sys.argv) == 1:
        files = sorted(Path(".").glob("Tabular_*.rtf"))
        if not files:
            Fatal("No Tabular_*.rtf files specified or found in current directory")
        source_file = files[-1]
    else:
        source_file = Path(sys.argv[1])
        if not source_file.exists():
            Fatal(f"File {source_file} does not exist")

    print(f"Processing:                    {source_file}...")
    with open(source_file, "r", encoding="utf-8") as f:
        rtf_content = f.read()

    lines = rtf_to_text(rtf_content)

    # Keep track of the parts for the 'path' column
    part = 0
    volume = 1
    part = 2
    chapter = 0
    subsection = 1
    category = 1
    category_entry = 1

    want_chapter = False
    chap = "?"
    range = "?"
    cat ="?"
    subcat = "?"

    codes = []
    ranges = {}

    prev_part = 1
    prev_chap = ""
    prev_cat = ""
    prev_subcat = ""

    csv_file = source_file.with_stem(source_file.stem.replace("Tabular", "Block_Structure")).with_suffix(".csv")
    csv_f = open(csv_file, "w", newline="", encoding="utf-8")
    writer = csv.writer(csv_f)
    print(f"CSV file will be created as:   {csv_file}")

    if openpyxl:
        sheet_file = csv_file.with_suffix(".xlsx")

        wb = Workbook()
        ws_notes = wb.active
        ws_notes.title = "Notes"

        ws = wb.create_sheet("OPCS4 Block Structure")
        print(f"Excel file will be created as: {sheet_file}")
    else:
        print("No .xlsx will be produced as there is no 'openpyxl' module.  Use 'pip3 install openpyxl' to get it.")

    def note(chap: str, range: str, cat: str, subcat: Optional[str]=None):
        """ Note the deletion of a code if we're generating an Excel file
        """
        if not openpyxl:
            return
        note.count = static_attr("count", 0)
        if note.count == 0:
            output(["The following are not included:"], "plain", sheet=ws_notes)
            output([], "plain", sheet=ws_notes)
            output(["Chapter", "Range", "Category", "Subcategory"], "heading", sheet=ws_notes)

            # ws_notes.append(["Chapter", "Range", "Category", "Subcategory"])
        note.count += 1
        output([chap, range, cat, subcat], "body", sheet=ws_notes)
        # ws_notes.append([chap, range, cat, subcat])

    output(["Path", "Chapter", "Range", "Category", "Subcategory"], "heading")
    total = len(lines)
    last_pc = -1
    for lineno, line in enumerate(lines):

        # Keep track of progress as Excel generation is slothful
        pc = int(lineno / total * 100)
        if pc != last_pc:
            print(f"\r{pc}% complete...", end="", flush=True)

        # Keep track of which part we're in
        if m := re.match(r"Part (\d)", line):
            part = int(m.group(1))
            continue

        # We need to process part 1 to get the ranges
        if part == 1:
            part1(line)
            continue

        # We need to push an extra line to part1 so it processes the last range
        if part == 2 and prev_part == 1:
            part1("")
        prev_part = part

        # Chapters are a line saying "CHAPTER A", followed by the chapter name on the next line
        if line.startswith("CHAPTER "):
            chap = line[8:]             # Bit nasty, but effective
            want_chapter = True
            continue

        if want_chapter:                # The chapter name line
            chap = chap + ". " + line
            want_chapter = False
            continue

        # We're now only interested in lines of the form code<TAB>text
        if "\t" not in line:
            continue

        code, text = line.split("\t", 1)
        text = text.strip()
        m = re.match(r"([A-Z][0-9]+)(\.[0-9])?", code)

        # Skip lines that don't start with a code
        if not m:
            continue

        code = m.group(1)       # A01
        sub = m.group(2)        # .1

        # there wasn't a .n part then it's a category so just note it
        if not sub:
            cat = f"{code} {text}"
            if text.lower().startswith("code deleted"):
                note(chap, range, cat)
                Debug(f"cat {code} is deleted")
                continue
            continue

        subcat = f"{code}{sub} {text}"
        range = ranges[code]
        if text.lower().startswith("code retired"):
            note(chap, range, cat, subcat)
            Debug(f"subcat {subcat} is retired")
            continue

        if text.lower().startswith("code deleted"):
            note(chap, range, cat, subcat)
            Debug(f"subcat {subcat} is deleted")
            continue

        # Bump our numbers up for the 'path' column
        if chap != prev_chap:
            chapter += 1
            category = 1
            category_entry = 1
        elif cat != prev_cat:
            category += 1
            category_entry = 1
        else:
            category_entry += 1
        prev_chap = chap
        prev_cat = cat
        path = f"/Volume[{volume}]/Part[{part}]/Chapter[{chapter}]Subsection[{subsection}]/Category[{category}]/CategoryEntry[{category_entry}]"

        output([path, chap, range, cat, subcat], "body")

    csv_f.close()

    if openpyxl:
        for col, width in {"A": 42, "B": 26, "C": 40, "D": 128}.items():
            ws_notes.column_dimensions[col].width = width + 17
            ws_notes.auto_filter.ref = f"A3:D{ws_notes.max_row}"
            ws_notes.freeze_panes = ws_notes.cell(4, 1)

        for col, width in {"A": 50, "B": 42, "C": 26, "D": 40, "E": 128}.items():
            ws.column_dimensions[col].width = width + 17
            ws.auto_filter.ref = f"A1:E{ws.max_row}"
            ws.freeze_panes = ws.cell(2, 1)

        wb.save(sheet_file)

    print("\rFinished!    ", end="")

